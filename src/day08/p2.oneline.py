((lcm := __import__("math", globals(), locals(), ["lcm"], 0).lcm),(cycle := __import__("itertools", globals(), locals(), ["cycle"], 0).cycle),(print := __import__("rich", globals(), locals(), ["print"], 0).print),(Node := type("Node",(object,),{"__init__": lambda self, name, left, right: [(setattr(self, "name", name)),(setattr(self, "left", left)),(setattr(self, "right", right)),None,][-1]},)),(load_input := __import__("loader", globals(), locals(), ["load_input"], 0).load_input), (solve := (lambda data: [(instructions := data[0]), (nodes_data := data[2:]), (nodes:= {}), [[(_split := node.split(" = ")), (name := _split[0]), (lr := _split[1]), (nodes.__setitem__(name, Node(name, *lr[1:-1].split(", "))))]for node in nodes_data], (starting_nodes := ((nodes[key], 0) for key in nodes if key.endswith("A"))), (path_lengths := []), [[(current:=c), (step_count:=sc), (instruction_cycle := type("wrapper",(),{"__init__": lambda self, it: [setattr(self, "it", iter(it)),setattr(self, "_break", False),None, ][-1], "__iter__": lambda self: self, "__next__": lambda self: next(iter([])) if self._break else next(self.it),},)(cycle(instructions))), [[(step_count := step_count + 1), (new_node := nodes[current.left if instruction == "L" else current.right]), [path_lengths.append(step_count), setattr(instruction_cycle, "_break", True)] if new_node.name.endswith("Z") else ..., (current := new_node),]for instruction in instruction_cycle]] for c, sc in starting_nodes], print("Path Lengths:", path_lengths), print("Answer (LCM): ", lcm(*path_lengths)),])), load_input(__file__, solve) if __name__ == "__main__" else ...,)
