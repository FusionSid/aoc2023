((cycle := __import__("itertools", globals(), locals(), ["cycle"], 0).cycle),(print := __import__("rich", globals(), locals(), ["print"], 0).print),(load_input := __import__("loader", globals(), locals(), ["load_input"], 0).load_input),[(Node := type("Node", (object,), {"__init__": lambda self, name, left, right: [(setattr(self, "name", name)), (setattr(self, "left", left)), (setattr(self, "right", right)), None][-1]})),], (solve := (lambda data: [(instructions := data[0]), (nodes_data := data[2:]), (nodes := {}), [[(splitted := node.split(" = ")), (name:= splitted[0]), (lr := splitted[1]), nodes.__setitem__(name, Node(name, *lr[1:-1].split(", ")))] for node in nodes_data], (current := "AAA"), (c := 0), (instruction_cycle := type("wrapper", (), {"__init__": lambda self, it: [setattr(self, "it", iter(it)),setattr(self, "_break", False), None][-1], "__iter__": lambda self: self, "__next__": lambda self: next(iter([])) if self._break else next(self.it)})(cycle(instructions))), [[(n := nodes[current]), setattr(instruction_cycle, "_break", True) if n.name == "ZZZ" else ..., (c :=c+ 1), (current := n.left if instruction == "L" else n.right)] for instruction in instruction_cycle], print(c-1),])), load_input(__file__, solve) if __name__ == "__main__" else ...,)
